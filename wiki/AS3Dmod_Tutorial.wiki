=The AS3Dmod Tutorial (in progress) =

===Introduction===

AS3Dmod is a cross-engine modifier library for creating 3d animations in Flash and AS3.

To create 3d animations using AS3Dmod you will need the following:

  * *Actionscript3 editor*: [http://www.flashdevelop.org/community/ FlashDevelop], [http://fdt.powerflasher.com/ FDT] or [http://www.adobe.com/products/flex/ FlexBuilder]. The Flash IDE is not recommended. If you don't have any favorite editor use [http://www.flashdevelop.org/community/ FlashDevelop] which is available for free. 

  * *A Flash 3D engine* AS3Dmod currently works with [http://blog.papervision3d.org Papervision3d], [http://www.away3d.com Away3d], [http://www.sandy3d.com Sandy3d] and [http://alternativaplatform.com/en/ Alternativa3d]. This tutorial features examples in Papervision3d. Again, I recommend using the latest version from the projects' respective SVN repositories. 

  * *AS3Dmod library* It is strongly recommended to use the latest version from SVN [http://code.google.com/p/as3dmod/source/browse/trunk available here].

  * *Tweener* We will use [http://code.google.com/p/tweener/ Tweener] in the animation examples, althought any other AS3 tweening library should also work.

===1. Setting up the workspace===

As I mentioned above, this tutorial will assume that you use Papervision3D for you Flash 3D development. If you intend to use AS3Dmod with other supported engines, you will need to adapt your code. However, the rules apply the same way to any engine, so this tutorial is still valid.

To start with, create a project in your AS3 editor and make sure you have the Papervision3D classes as well as AS3Dmod classes in your classpath. To make things easier, we will extend the class `BasicView` to create ad 3d scene to work on. Here's our starting point:

{{{
package com.as3dmod.tutorial {
	import org.papervision3d.cameras.CameraType;
	import org.papervision3d.materials.WireframeMaterial;
	import org.papervision3d.objects.primitives.Plane;
	import org.papervision3d.view.BasicView;
	
	import flash.events.Event;	

	public class AS3DmodTutorial extends BasicView {

		private var plane:Plane;

		public function AS3DmodTutorial() {
			super(800, 600, true, false, CameraType.FREE);
			var mat:WireframeMaterial = new WireframeMaterial();
			mat.doubleSided = true;
			plane = new Plane(mat, 300, 300, 10, 10);
			plane.rotationX = 45;
			plane.rotationY = 45;
			scene.addChild(plane);
			startRendering();
		}
		
		protected override function onRenderTick(event:Event = null):void {
			super.onRenderTick(event);
		}
	}
}
}}}

The beauty of `BasicView` is that it does all the job of creating the 3d environment for us. The only thing we need to do is to create a plane to which we will later apply the modifiers. The plane is rotated on the X and Y axes a bit to give it a better 3d look.

The `onRenderTick` function is called on each frame before the scene is rendered - another thing `BasicView` does for us. Now it is empty, but we will use it to animate the modifier properties later.

===2. Creating modifer stack===

The first step with AS3Dmod is to create a modifier stack. The modifier stack is a link between the 3d object that we want to modify and the modifiers themselves. The modifier stack is a central class of the whole AS3Dmod llibrary. It is important to note that modifiers cannot be applied directly to a 3d object. Everything is handled by the stack. Here's the import:

{{{
import com.as3dmod.ModifierStack;
}}}

Since we might want to use the stack in different places in our code, it is always recommended to declare is as class member variable.

{{{
private var mstack:ModifierStack;
}}}

After that, in the constructor, before the call to the `startRendering()` we can create the instance of the stack:

{{{
mstack = new ModifierStack(new LibraryPv3d(), plane);
}}}

This important line creates the stack by providing it with two arguments. The first one indicates the 3d library we are using, by creating an instance of a special class. Here are the classes that you need to use for each of the supported libraries:

{{{
com.as3dmod.plugins.sandy3d.LibrarySandy3d;	
com.as3dmod.plugins.alternativa3d.LibraryAlternativa3d;	
com.as3dmod.plugins.away3d.LibraryAway3d;	
com.as3dmod.plugins.pv3d.LibraryPv3d;
}}}

Just creating the instance of the right class like show above is enough, and you do not need to care about anything 3d engine related anymore - just use the modifiers.

The second argument is the 3d object that the modifiers will be applied to. We pass the plane created before. AS3Dmod works with any 3d object, including all the primitives (planes, cubes, spheres, etc) as well as with different imported types like Collada DAE or Wavefront OBJ (available in Away3d). 

However, if you want to apply the modifiers to Collada objects, you need to make sure you pass as argument the object that holds the geometry data (typically a child of the root object in a Collada file). I goes beyond the scope of this tutorial anyway :)

===3. Creating modifiers===

The fun begins! Let's start with a simple bend. Immediately after you created the modifier stack, add the following lines:

{{{
var noise:Noise = new Noise(20);
mstack.addModifier(noise);
mstack.apply();
}}}

Compile your class, and you will see that the plane is randomly displaced - this is what the Noise modifier does. 

Let's examine the code. In the first line you create a modifier. Noise is one of the family of modifiers. The argument indicates the force of the effect - you can different values here. 0 means no deformation at all, while a value somewhere around a 200 creates such a strong deformation that it doesn't make much sense any more.

Once the modifier is created it needs to be added the the stack. That is the only way it can be applied to the 3d object. 

This is good place to not one important feature. It DOES matter in which order the modifiers are added to the stack. The first ones added will be the first ones applied, and each modifier is applied to an object already transformed by any modifiers that were applied before him. Sometimes the difference won't be important, but in other cases changing the order the modifiers are added to the stack can completely change the final visual effect. It is always good to experiment with that, because in most cases the results are hard to predict. 

The last line in the code above has a key importance. It tells the stack to apply ALL the modifiers to 3d object. What is important to understand here is that the modifiers are applied and deform the object but its original geometry (i.e. shape) is conserved. Whenever `apply()` is invoked again all the modifiers are applied on the original geometry of the object. In other words: calling apply multiple times gives end up always with the final result.

===4. Changing & tweening modifier properties===

Obviously, modifiers are most useful when used to animate object. In order to do this we need to change properties of the modifier in a regular timespan, and after each change call the `apply()`. Typically in Flash the best place to do this is on each frame just before calling the rendering function of the engine. 

The Noise modifier that we added before is very simple and not very useful for animation purposes. Let's remove it and add another one instead:

{{{
import com.as3dmod.modifiers.Perlin;

[...]

var perlin:Perlin = new Perlin(2);
mstack.addModifier(perlin);
}}}

We do not call the `apply()` method here anymore. Instead we will call it on every frame. In the BasicView class, the the place where it should be done is the `onRenderTick` method already mentioned above:

{{{
protected override function onRenderTick(event:Event = null):void {
	stack.apply();
	super.onRenderTick(event);
}
}}}

If you run the code you should see the plane waving gently as if it was a cloth exposed to  wind. This is the effect of the Perlin modifier. The animation is made possible because `apply()` is called on each frame. 

If you are 

===5. Using Phase===

{{{
var phase:Phase = new Phase();
}}}

===6. Collapsing the modifier stack===

{{{
stack.collapse();
}}}